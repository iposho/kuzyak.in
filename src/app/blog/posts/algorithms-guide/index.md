---
title: "Конспект руководств по алгоритмам и структурам данных с примерами на JavaScript"
description: "Обзор ключевых алгоритмов и структур данных с примерами на JavaScript, основанный на книге «Грокаем алгоритмы»"
date: "2024-12-20"
tags: ["algorithms", "javascript", "data-structures", "programming", "computer-science"]
author: "Pavel Kuzyakin"
coverImage: "/images/blog/algorithms-guide.jpg"
---

## Оглавление

- [Введение](#введение)
- [Бинарный поиск](#бинарный-поиск)
- [Сортировка выбором](#сортировка-выбором)
- [Рекурсия](#рекурсия)
- [Быстрая сортировка](#быстрая-сортировка)
- [Хеш-таблицы (структура данных)](#хеш-таблицы-структура-данных)
- [Поиск в ширину (BFS)](#поиск-в-ширину-bfs)
- [Алгоритм Дейкстры](#алгоритм-дейкстры)
- [Жадные алгоритмы: задача о покрытии множества](#жадные-алгоритмы-задача-о-покрытии-множества)
- [Динамическое программирование: задача о рюкзаке](#динамическое-программирование-задача-о-рюкзаке)
- [Алгоритм k ближайших соседей (k-NN)](#алгоритм-k-ближайших-соседей-k-nn)
- [Заключение](#заключение)
- [Словарь терминов](#словарь-терминов)
- [Источники](#источники)

---

## Введение

Данный документ — обзор ключевых алгоритмов и структур данных, описанных в книге «Грокаем алгоритмы» Адитьи Бхаргавы, с примерами на JavaScript. Для каждого алгоритма указаны назначение, принцип работы, оценка производительности в нотации [O-большое](#term-bigo) и код.

Реализации — авторские интерпретации.

---

## Бинарный поиск

Бинарный поиск — это алгоритм, который на вход получает отсортированный список элементов и возвращает позицию искомого элемента, если он найден, или null, если его нет. 
Он работает намного быстрее простого поиска. Вместо того чтобы последовательно проверять каждый элемент, бинарный поиск каждый раз исключает половину оставшихся элементов. 

> Представь, что ты ищешь слово в бумажном словаре. Ты не листаешь страницу за страницей. Вместо этого открываешь словарь посередине: если нужное слово должно быть раньше — идёшь влево, если позже — вправо. Каждое действие отбрасывает половину словаря.

**Сложность:** O(log n)

```js
function binarySearch(list, item) {
    let low = 0;
    let high = list.length - 1;

    while (low <= high) {
        const mid = Math.floor((low + high) / 2);
        const guess = list[mid];

        if (guess === item) return mid;
        if (guess > item) high = mid - 1;
        else low = mid + 1;
    }
    return null;
}
```

---

## Сортировка выбором

Сортировка выбором — это алгоритм сортировки, который последовательно находит наибольший (или наименьший) элемент в оставшемся списке и перемещает его в новый отсортированный список. 

> Ты собираешь стопку книг по росту. Сначала находишь самую маленькую книгу и кладёшь её на стол. Потом из оставшихся выбираешь снова самую маленькую. Так продолжается, пока все книги не будут выстроены в ряд.

**Сложность:** O(n²)

```js
function findSmallest(arr) {
    let smallest = arr[0];
    let smallestIndex = 0;

    for (let i = 1; i < arr.length; i++) {
        if (arr[i] < smallest) {
            smallest = arr[i];
            smallestIndex = i;
        }
    }
    return smallestIndex;
}

function selectionSort(arr) {
    const newArr = [];
    const copy = [...arr];
    for (let i = 0; i < arr.length; i++) {
        const smallestIndex = findSmallest(copy);
        newArr.push(copy.splice(smallestIndex, 1)[0]);
    }
    return newArr;
}
```

---

## Рекурсия

**Описание.** Метод, при котором функция вызывает саму себя ([рекурсия](#term-recursion)). Требует базового случая, чтобы остановить вызовы (иначе переполнение [стека вызовов](#term-callstack)).

Пример: факториал.

> Матрёшка: открываешь большую куклу, находишь внутри меньшую, потом ещё меньшую, пока не дойдёшь до самой маленькой. Когда открывать больше нечего — начинаешь собирать их обратно.

```js
function factorial(n) {
    if (n === 1) return 1; // базовый случай
    return n * factorial(n - 1); // рекурсивный случай
}
```

---

## Быстрая сортировка

**Описание.** «Разделяй и властвуй». Делит массив на подмассивы и рекурсивно сортирует.

> Представь, что ты раскладываешь карточки по числам. Берёшь одну карточку как «опорную», кладёшь её на стол, слева — все, что меньше, справа — все, что больше. Потом повторяешь ту же процедуру для левой и правой стопки, пока все стопки не будут состоять из одной карточки.

**Сложность:** Средний случай — O(n log n), худший — O(n²)

```js
function quicksort(arr) {
    if (arr.length < 2) return arr;
    const pivot = arr[0];
    const less = arr.slice(1).filter(x => x <= pivot);
    const greater = arr.slice(1).filter(x => x > pivot);
    return [...quicksort(less), pivot, ...quicksort(greater)];
}
```

---

## Хеш-таблицы (структура данных)

**Описание.** Структура для хранения пар «ключ‑значение» ([хеш-таблица](#term-hashmap)). Доступ к элементу — `O(1)` в среднем.

Пример: проверка гостей на вечеринке.

> Представь гардероб с номерками. Ты отдаёшь пальто, тебе дают номерок (ключ). Когда возвращаешься, по номерку сразу находят твоё пальто.

```js
const guests = new Map();
guests.set("Иван", true);
console.log(guests.get("Иван")); // true
```

---

## Поиск в ширину (BFS)

**Описание.** Алгоритм обхода графа, ищет кратчайший путь ([BFS](#term-bfs)). Работает через очередь.

> Ты ищешь друга в толпе. Сначала проверяешь всех, кто стоит рядом с тобой. Если его нет, спрашиваешь у соседей, кто рядом с ними, и так постепенно расширяешь круг.

```js
function bfs(graph, start) {
    const queue = [...graph[start]];
    const searched = new Set();

    while (queue.length > 0) {
        const person = queue.shift();
        if (!searched.has(person)) {
            if (person.endsWith("m")) return person;
            else queue.push(...graph[person]);
            searched.add(person);
        }
    }
    return null;
}
```

**Сложность:** O(V+E)

---

## Алгоритм Дейкстры

**Описание.** Находит кратчайший путь в графе с положительными весами.

> Представь карту с дорогами и расстояниями. Ты хочешь доехать быстрее всего от дома до работы. Алгоритм помогает выбрать путь с наименьшими суммарными затратами времени.

**Сложность:** `O(V²)` или быстрее при использовании кучи.

```js
function dijkstra(graph, start) {
    const costs = Object.assign({}, graph[start]);
    const processed = new Set();

    function findLowestCostNode(costs) {
        let lowestCost = Infinity;
        let lowestNode = null;
        for (const node in costs) {
            if (!processed.has(node) && costs[node] < lowestCost) {
                lowestCost = costs[node];
                lowestNode = node;
            }
        }
        return lowestNode;
    }

    let node = findLowestCostNode(costs);
    while (node) {
        const cost = costs[node];
        const neighbors = graph[node];
        for (const n in neighbors) {
            const newCost = cost + neighbors[n];
            if (!costs[n] || costs[n] > newCost) costs[n] = newCost;
        }
        processed.add(node);
        node = findLowestCostNode(costs);
    }
    return costs;
}
```

---

## Жадные алгоритмы: задача о покрытии множества

**Описание.** Жадный выбор — покрывать максимум за один шаг. Не всегда оптимально, но быстро.

> Представь, что тебе нужно охватить все районы города рекламой. У тебя есть несколько билбордов, каждый из которых виден в разных районах. Ты выбираешь сначала тот, что охватывает больше всего новых районов, потом следующий, пока не закроешь все.

---

## Динамическое программирование: задача о рюкзаке

**Описание.** Заполнение таблицы состояний для нахождения оптимума. `O(n·W)` (где `W` — вместимость).

> Представь, что ты собираешь рюкзак в путешествие. У тебя ограниченный вес, и ты решаешь, что положить: ноутбук, гитару или еду. Ты ищешь комбинацию, которая даст максимальную пользу при ограниченной вместимости.

---

## Алгоритм k ближайших соседей (k-NN)

**Описание.** Классификация по ближайшим точкам в пространстве признаков.

Пример: рекомендации фильмов.

> Представь, что ты переехал в новый район и хочешь понять, какой у тебя будет интернет. Ты спрашиваешь ближайших соседей: если большинство довольны провайдером X, то и ты, скорее всего, выберешь его.

```js
function euclideanDistance(point1, point2) {
    return Math.sqrt(point1.reduce((sum, val, i) => sum + (val - point2[i])**2, 0));
}
```

---

## Словарь терминов

<details>
  <summary>Развернуть</summary>
  
    
<a name="term-bigo"></a>
### O-большое
Асимптотическая сложность алгоритма, отражает зависимость времени выполнения от размера входа.

> Если нужно отсортировать список, то чем больше элементов, тем дольше работа. В терминах O-большого говорят: «сортировка выбором работает за O(n²)», то есть время увеличивается примерно как квадрат длины списка. 

<a name="term-recursion"></a>
### Рекурсия
Метод, при котором функция вызывает саму себя.

> Представь, что нужно посчитать факториал числа. Вместо длинного цикла можно сказать: `n! = n * (n-1)!`. Функция просто вызывает сама себя, пока не дойдёт до 1.  

<a name="term-callstack"></a>
### Стек вызовов
Структура, в которой хранится информация о выполняемых функциях.

> Если вызвать функцию А, которая вызывает функцию B, та вызывает C, то в стеке сверху будет C. Когда C закончит, её уберут из стека, и управление вернётся к B, потом к A.  

<a name="term-hashmap"></a>
### Хеш-таблица
Структура данных для быстрого доступа к элементам по ключу.
    
> Телефонная книга. Имя человека — это ключ, а номер телефона — значение. Хеш-таблица позволяет мгновенно найти номер по имени, не перебирая всю книгу.      

<a name="term-bfs"></a>
### Поиск в ширину (BFS)
Алгоритм обхода графа, ищет кратчайший путь.
    
> Если хочешь найти кратчайший путь до друга в социальной сети, алгоритм сначала проверяет всех твоих друзей, потом друзей друзей, потом друзей их друзей — и так далее, пока не найдёт нужного человека.      

---
    
</details>

## Заключение

Алгоритмы — основа эффективности программирования. Их понимание и практика дают возможность писать быстрый и оптимизированный код.

---

## Источники

- Адитья Бхаргава. «Грокаем алгоритмы»  
- Wikipedia (статьи о каждом алгоритме)  
